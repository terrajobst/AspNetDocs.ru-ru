---
uid: mvc/overview/getting-started/getting-started-with-ef-using-mvc/advanced-entity-framework-scenarios-for-an-mvc-web-application
title: Учебник. Дополнительные сведения о сложных сценариях EF для веб-приложения MVC 5
description: В этом учебнике представлено несколько подразделов, которые помогут вам помнить о том, что вы выходите за пределы основ разработки веб-приложений ASP.NET, использующих Entity Framework Code First.
author: tdykstra
ms.author: riande
ms.date: 01/22/2019
ms.topic: tutorial
ms.assetid: f35a9b0c-49ef-4cde-b06d-19d1543feb0b
msc.legacyurl: /mvc/overview/getting-started/getting-started-with-ef-using-mvc/advanced-entity-framework-scenarios-for-an-mvc-web-application
msc.type: authoredcontent
ms.openlocfilehash: d7cc83a5b78a60f575f5c3065079679189296a0c
ms.sourcegitcommit: 4b324a11131e38f920126066b94ff478aa9927f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "58425279"
---
# <a name="tutorial-learn-about-advanced-ef-scenarios-for-an-mvc-5-web-app"></a>Учебник. Дополнительные сведения о сложных сценариях EF для веб-приложения MVC 5

В предыдущем учебном курсе было реализовано наследование «таблица на иерархию». В этом учебнике представлено несколько подразделов, которые помогут вам помнить о том, что вы выходите за пределы основ разработки веб-приложений ASP.NET, использующих Entity Framework Code First. В первых нескольких разделах содержатся пошаговые инструкции по выполнению кода и использованию Visual Studio для выполнения задач. в следующих разделах приведено несколько разделов с краткими сведениями, а также ссылки на ресурсы для получения дополнительных сведений.

В большинстве из этих разделов вы будете работать с уже созданными страницами. Чтобы использовать необработанный SQL для выполнения операций с массовыми обновлениями, создайте новую страницу, которая обновляет количество кредитов всех курсов в базе данных:

![Update_Course_Credits_initial_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image1.png)

В этом учебнике рассмотрены следующие задачи.

> [!div class="checklist"]
> * Выполнение прямых SQL-запросов
> * Выполнение запросов без отслеживания
> * Проверка запросов SQL, отправленных в базу данных

Вы также узнаете о следующих возможностях:

> [!div class="checklist"]
> * Создание слоя абстракции
> * Прокси-классы
> * Автоматическое обнаружение изменений
> * Автоматическая проверка
> * Entity Framework Power Tools
> * Исходный код Entity Framework

## <a name="prerequisite"></a>Предварительное требование

* [Реализация наследования](implementing-inheritance-with-the-entity-framework-in-an-asp-net-mvc-application.md)

## <a name="perform-raw-sql-queries"></a>Выполнение прямых SQL-запросов

API Entity Framework Code First содержит методы, позволяющие передавать команды SQL непосредственно в базу данных. Можно выбрать один из следующих параметров.

- Используйте метод [DbSet. SqlQuery](https://msdn.microsoft.com/library/system.data.entity.dbset.sqlquery.aspx) для запросов, возвращающих типы сущностей. Возвращаемые объекты должны иметь тип, ожидаемый `DbSet` объектом, и они автоматически отслеживаются контекстом базы данных, если не отключить отслеживание. (Сведения о методе [asnotrackin](https://msdn.microsoft.com/library/system.data.entity.dbextensions.asnotracking.aspx) см. в следующем разделе.)
- Используйте метод [Database. SqlQuery](https://msdn.microsoft.com/library/system.data.entity.database.sqlquery.aspx) для запросов, возвращающих типы, которые не являются сущностями. Возвращаемые данные не отслеживаются контекстом базы данных, даже если вы используете этот метод для извлечения типов сущностей.
- Используйте параметр [Database. ексекутесклкомманд](https://msdn.microsoft.com/library/gg679456.aspx) для команд, не относящихся к запросу.

Одним из преимуществ использования платформы Entity Framework является возможность избежать слишком тесной привязки кода к конкретному способу хранения данных. Это достигается путем автоматического создания запросов и команд SQL, что позволяет упростить написание кода. Но существуют исключительные ситуации, когда необходимо выполнить определенные запросы SQL, созданные вручную, и эти методы позволят вам справиться с такими исключениями.

Как и всегда при выполнении команд SQL в веб-приложении, необходимо принимать меры предосторожности для защиты сайта от атак путем внедрения кода SQL. Одним из способов защиты является применение параметризованных запросов, которые гарантируют, что строки, отправляемые веб-страницей, не могут быть интерпретированы как команды SQL. В рамках этого учебника вы будете использовать параметризованные запросы при интеграции вводимых пользователем данных в запрос.

### <a name="calling-a-query-that-returns-entities"></a>Вызов запроса, возвращающего сущности

Класс [DbSet&lt;домика&gt; ](https://msdn.microsoft.com/library/gg696460.aspx) предоставляет метод, который можно использовать для выполнения запроса, возвращающего сущность типа `TEntity`. Чтобы увидеть, как это работает, измените код в `Details` методе `Department` контроллера.

В *DepartmentController.CS*в `Details` `db.Departments.SqlQuery` методе замените вызов методанавызовметода,какпоказановследующемвыделенномкоде:`db.Departments.FindAsync`

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample1.cs?highlight=8-14)]

Чтобы убедиться, что новый код работает правильно, выберите вкладку **Departments** (Кафедры) и щелкните **Details** (Сведения) для одной из кафедр. Убедитесь, что все данные отображаются должным образом.

### <a name="calling-a-query-that-returns-other-types-of-objects"></a>Вызов запроса, возвращающего другие типы объектов

Ранее вы создали таблицу статистики учащихся на странице сведений, в которой было показано число учащихся на каждую дату регистрации. Код, который делает это в *HomeController.CS* , использует LINQ:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample2.cs)]

Предположим, что вам нужно написать код, извлекающий эти данные непосредственно в SQL, а не использовать LINQ. Для этого необходимо выполнить запрос, который возвращает нечто, отличное от объектов сущности, что означает необходимость использования метода [Database. SqlQuery](https://msdn.microsoft.com/library/system.data.entity.database.sqlquery(v=VS.103).aspx) .

В *HomeController.CS*Замените инструкцию LINQ в `About` методе на инструкцию SQL, как показано в следующем выделенном коде:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample3.cs?highlight=3-18)]

Запуск страницы About. Убедитесь, что в нем отображаются те же данные, что и ранее.

### <a name="calling-an-update-query"></a>Вызов запроса на обновление

Предположим, администраторы университета Contoso хотят иметь возможность выполнять групповые изменения в базе данных, например изменять количество кредитов для каждого курса. Поскольку в университете ведется множество курсов, будет неэффективно извлекать их в виде сущностей и изменять по отдельности. В этом разделе вы реализуете веб-страницу, с помощью которой пользователь должен указать коэффициент, на который нужно изменить количество кредитов для всех курсов, и внести изменения, выполнив инструкцию SQL `UPDATE` . 

В *CourseController.CS*добавьте `UpdateCourseCredits` методы для `HttpGet` и `HttpPost`:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample4.cs)]

Когда контроллер обрабатывает `HttpGet` запрос, `ViewBag.RowsAffected` в переменной не возвращается ничего, а в представлении отображается пустое текстовое поле и кнопка отправки.

При нажатии `HttpPost` кнопки **Обновить** вызывается метод, и `multiplier` ему задается значение, указанное в текстовом поле. Затем код выполняет инструкцию SQL, которая обновляет курсы и возвращает количество затронутых строк в представление в `ViewBag.RowsAffected` переменной. Когда представление получает значение в этой переменной, оно отображает число обновляемых строк вместо текстового поля и кнопки Отправить.

В *CourseController.CS*щелкните правой кнопкой мыши один из `UpdateCourseCredits` методов и выберите команду **Добавить представление**. Откроется диалоговое окно **Добавление представления** . Оставьте значения по умолчанию и нажмите кнопку **Добавить**.

В *виевс\каурсе\упдатекаурсекредитс.кштмл*замените код шаблона следующим кодом:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample5.cshtml)]

Выполните метод `UpdateCourseCredits`, выбрав вкладку **Courses** (Курсы), а затем добавив "/UpdateCourseCredits" в конец URL-адреса в адресной строке браузера (например, `http://localhost:50205/Course/UpdateCourseCredits`). Введите число в текстовое поле:

![Update_Course_Credits_initial_page_with_2_entered](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image1.png)

Нажмите кнопку **Обновить**. Отображается число затронутых строк.

Нажмите кнопку **Back to List** (Вернуться к списку), чтобы просмотреть список курсов с измененным числом зачетных баллов.

Дополнительные сведения о необработанных запросах SQL см. в статье [необработанные запросы SQL](https://msdn.microsoft.com/data/jj592907) в MSDN.

## <a name="no-tracking-queries"></a>Отключение отслеживания запросов

Когда контекст базы данных извлекает строки таблицы и создает представляющие их объекты сущностей, по умолчанию отслеживается состояние синхронизации сущностей в памяти с содержимым базы данных. При обновлении сущности данные в памяти выступают в роли кэша. В веб-приложении такое кэширование часто не нужно, поскольку экземпляры контекста, как правило, существуют недолго (для каждого запроса создается и ликвидируется собственный экземпляр), и контекст, считывающий сущность, как правило, ликвидируется до того, как сущность будет использована снова.

Отслеживание объектов сущностей в памяти можно отключить с помощью метода [asnotrackin](https://msdn.microsoft.com/library/gg679352(v=vs.103).aspx) . Как правило, это требуется в следующих сценариях:

- Запрос получает такой большой объем данных, при котором отключение отслеживания может заметно повысить производительность.
- Вы хотите присоединить сущность, чтобы обновить ее, но вы ранее извлекли ту же сущность для другой цели. Поскольку сущность уже отслеживается контекстом базы данных, присоединить сущность, которую требуется изменить, нельзя. Одним из способов решения этой ситуации является использование `AsNoTracking` параметра с предыдущим запросом.

Пример, демонстрирующий использование метода [asnotrackin](https://msdn.microsoft.com/library/gg679352(v=vs.103).aspx) , см. [в более ранней версии этого руководства](../../older-versions/getting-started-with-ef-5-using-mvc-4/advanced-entity-framework-scenarios-for-an-mvc-web-application.md). Эта версия руководства не устанавливает измененный флаг в сущности, созданной связывателем модели, в методе Edit, поэтому он не нужен `AsNoTracking`.

## <a name="examine-sql-sent-to-database"></a>Проверка SQL, отправленного в базу данных

В некоторых случаях полезно иметь возможность просмотреть фактические SQL-запросы, отправляемые в базу данных. В предыдущем учебнике вы узнали, как это сделать в коде перехватчика; Теперь вы можете увидеть несколько способов, не создавая код перехватчика. Чтобы попробовать это, рассмотрим простой запрос, а затем посмотрим, что происходит с ним при добавлении параметров, таких как упреждающая загрузка, фильтрация и сортировка.

В *Controllers/каурсеконтроллер*замените `Index` метод следующим кодом, чтобы временно остановить безотлагательную загрузку:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample6.cs)]

Теперь установите точку останова в `return` операторе (F9 с курсором в этой строке). Нажмите клавишу **F5** , чтобы запустить проект в режиме отладки, и выберите страницу индекса курса. Когда код достигает точки останова, изучите `sql` переменную. Отобразится запрос, отправленный в SQL Server. Это простая `Select` инструкция.

[!code-json[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample7.json)]

Щелкните увеличительное стекло, чтобы увидеть запрос в **визуализаторе текста**.

![](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image10.png)

Теперь вы добавите раскрывающийся список на страницу индекса курсов, чтобы пользователи могли выполнять фильтрацию по определенному отделу. Вы сортируете курсы по названию и указываете безотлагательную загрузку для `Department` свойства навигации.

В *CourseController.CS*замените `Index` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample8.cs)]

Восстановите точку останова в `return` инструкции.

Метод получает выбранное значение раскрывающегося списка в `SelectedDepartment` параметре. Если ничего не выбрано, этот параметр будет иметь значение null.

`SelectList` Коллекция, содержащая все отделы, передается в представление раскрывающегося списка. Параметры, передаваемые в `SelectList` конструктор, указывают имя поля значения, имя текстового поля и выбранный элемент.

`Get` Для метода `Course` репозитория в коде указывается критерий фильтра, порядок сортировки `Department` и упреждающая загрузка для свойства навигации. Критерий фильтра всегда возвращает `true` значение, если в раскрывающемся списке ничего не выбрано ( `SelectedDepartment` то есть равно null).

В *виевс\каурсе\индекс.кштмл*непосредственно перед открывающим `table` тегом добавьте следующий код, чтобы создать раскрывающийся список и кнопку отправки:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample9.cshtml)]

Если точка останова по-прежнему задана, запустите страницу индекса курса. Продолжайте в первый раз, когда код достигает точки останова, чтобы страница отображалась в браузере. Выберите отдел в раскрывающемся списке и нажмите кнопку **Фильтр**.

На этот раз первая точка останова будет относиться к запросу отделов для раскрывающегося списка. Пропустите эту `query` переменную и просмотрите ее в следующий раз, когда код достигнет точки останова, чтобы `Course` увидеть, как будет выглядеть запрос. Вы увидите нечто вроде следующего:

[!code-sql[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample10.sql)]

Вы видите, `JOIN` что запрос теперь является запросом, который загружает `Department` данные вместе с `Course` данными и включает `WHERE` предложение.

`var sql = courses.ToString()` Удалите строку.

## <a name="create-an-abstraction-layer"></a>Создание уровня абстракции

Многие разработчики пишут код, реализующий шаблоны репозитория и единиц работы, в качестве оболочки для кода, работающего с платформой Entity Framework. Эти шаблоны позволяют создать уровень абстракции между уровнями доступа к данным и бизнес-логики приложения. Реализация таких шаблонов позволяет изолировать приложение от изменений в хранилище данных и упрощает автоматическое модульное тестирование или разработку на основе тестирования. Однако написание дополнительного кода для реализации этих шаблонов не всегда является лучшим выбором для приложений, использующих EF, по нескольким причинам:

- Класс контекста EF сам по себе изолирует код от кода хранилища данных.
- Класс контекста EF может выступать в качестве класса единиц работы для обновления базы данных, которые выполняются с помощью EF.
- Функции, появившиеся в Entity Framework 6, упрощают реализацию TDD без написания кода репозитория.

Дополнительные сведения о реализации шаблонов репозитория и единиц работы см. [в Entity Framework 5 версии этой серии руководств](../../older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application.md). Сведения о способах реализации TDD в Entity Framework 6 см. в следующих ресурсах:

- [Как EF6 делает макет Дбсетс проще](http://thedatafarm.com/data-access/how-ef6-enables-mocking-dbsets-more-easily/)
- [Тестирование с помощью инфраструктуры макетирования](https://msdn.microsoft.com/data/dn314429)
- [Тестирование с помощью пользовательских двойной проверки](https://msdn.microsoft.com/data/dn314431)

<a id="proxies"></a>

## <a name="proxy-classes"></a>Прокси-классы

Когда Entity Framework создает экземпляры сущности (например, при выполнении запроса), она часто создает их как экземпляры динамически создаваемого производного типа, который выступает в качестве прокси-сервера для сущности. Например, см. следующие два образа отладчика. На первом изображении видно, что `student` переменная является ожидаемым `Student` типом сразу после создания экземпляра сущности. На втором изображении после того, как EF использовался для чтения сущности Student из базы данных, вы увидите класс прокси.

![Класс прокси-сервера до](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image12.png)

![Класс прокси-сервера после](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image13.png)

Этот прокси-класс переопределяет некоторые виртуальные свойства сущности, чтобы вставить обработчики для выполнения действий автоматически при обращении к свойству. Одна из функций этого механизма используется для отложенной загрузки.

В большинстве случаев вам не нужно знать об использовании прокси-серверов, но существуют исключения.

- В некоторых случаях может потребоваться запретить Entity Framework создавать экземпляры прокси-сервера. Например, при сериализации сущностей обычно требуются классы POCO, а не прокси-классы. Одним из способов избежать проблем с сериализацией является сериализация объектов передаваемых данных (DTO) вместо объектов сущностей, как показано в руководстве по [использованию веб-API с Entity Framework](../../../../web-api/overview/data/using-web-api-with-entity-framework/part-1.md) . Другой способ — [отключить создание прокси-сервера](https://msdn.microsoft.com/data/jj592886.aspx).
- При создании экземпляра класса сущности с помощью `new` оператора вы не получаете экземпляр прокси-сервера. Это означает, что вы не получаете такие функции, как отложенная загрузка и автоматическое отслеживание изменений. Обычно это нормально. обычно отложенная загрузка не требуется, так как создается новая сущность, которая не находится в базе данных, и обычно не требуется отслеживание изменений, если вы явно помечаете сущность `Added`как. Однако, если требуется отложенная загрузка и требуется отслеживание изменений, можно создать новые экземпляры сущности с прокси-сервером с помощью метода `DbSet` [CREATE](https://msdn.microsoft.com/library/gg679504.aspx) класса.
- Может потребоваться получить фактический тип сущности из прокси-типа. Для получения фактического типа сущности экземпляра прокси-типа `ObjectContext` можно использовать метод [GetObjectType](https://msdn.microsoft.com/library/system.data.objects.objectcontext.getobjecttype.aspx) класса.

Дополнительные сведения см. в разделе [Работа с учетными записями-посредниками](https://msdn.microsoft.com/data/JJ592886.aspx) в MSDN.

## <a name="automatic-change-detection"></a>Автоматическое обнаружение изменений

Платформа Entity Framework определяет, как была изменена сущность (и, соответственно, какие обновления требуется отправить в базу данных), сравнивая текущие значения сущности с исходными. Исходные значения сохраняются при запросе или присоединении сущности. Ниже перечислены некоторые из методов, которые приводят к автоматическому обнаружению изменений:

- `DbSet.Find`
- `DbSet.Local`
- `DbSet.Remove`
- `DbSet.Add`
- `DbSet.Attach`
- `DbContext.SaveChanges`
- `DbContext.GetValidationErrors`
- `DbContext.Entry`
- `DbChangeTracker.Entries`

Если вы отслеживаете большое количество сущностей и вызываете один из этих методов несколько раз в цикле, вы можете значительно повысить производительность, временно отключив автоматическое обнаружение изменений с помощью свойства [аутодетектчанжесенаблед](https://msdn.microsoft.com/library/system.data.entity.infrastructure.dbcontextconfiguration.autodetectchangesenabled.aspx) . Дополнительные сведения см. в разделе [Автоматическое обнаружение изменений](https://msdn.microsoft.com/data/jj556205) на сайте MSDN.

## <a name="automatic-validation"></a>Автоматическая проверка

При вызове `SaveChanges` метода по умолчанию Entity Framework проверяет данные во всех свойствах всех измененных сущностей перед обновлением базы данных. Если вы обновили большое количество сущностей и уже проверили данные, эта работа не требуется, и процесс сохранения изменений займет меньше времени, временно отключив проверку. Это можно сделать с помощью свойства [валидатеонсавинаблед](https://msdn.microsoft.com/library/system.data.entity.infrastructure.dbcontextconfiguration.validateonsaveenabled.aspx) . Дополнительные сведения см. в разделе [Проверка](https://msdn.microsoft.com/data/gg193959) на сайте MSDN.

## <a name="entity-framework-power-tools"></a>Entity Framework Power Tools

[Entity Framework Power Tools](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) — это надстройка Visual Studio, которая использовалась для создания диаграмм моделей данных, приведенных в этих учебниках. Эти средства также могут выполнять другие функции, такие как создание классов сущностей на основе таблиц в существующей базе данных, чтобы можно было использовать базу данных с Code First. После установки средств некоторые дополнительные параметры отображаются в контекстных меню. Например, если щелкнуть правой кнопкой мыши класс контекста в **Обозреватель решений**, вы увидите и **Entity Framework** параметр. Это дает возможность создать схему. При использовании Code First нельзя изменить модель данных на диаграмме, но можно переместить их, чтобы упростить понимание.

![Схема EF](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image15.png)

## <a name="entity-framework-source-code"></a>Исходный код Entity Framework

Исходный код для Entity Framework 6 доступен на сайте [GitHub](https://github.com/aspnet/EntityFramework6). Вы можете завладеть ошибками и внести собственные улучшения в исходный код EF.

Несмотря на то, что исходный код открыт, Entity Framework полностью поддерживается как продукт Майкрософт. Команда Microsoft Entity Framework контролирует предложения участников, принимает их и тестирует любые изменения кода, чтобы обеспечить максимальное качество каждого выпуска.

## <a name="acknowledgments"></a>Благодарности

- Tom Dykstra) написал исходную версию этого руководства, соавторство обновления EF 5 и написал обновление EF 6. Tom — старший специалист по программированию для веб-платформы и разработчиков содержимого Microsoft.
- [Рик Андерсон (](https://blogs.msdn.com/b/rickandy/) (Twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT)) выполнил большую часть работы по обновлению руководства для EF 5 и MVC 4 и совместно с обновлением EF 6. Рик — старший специалист по программированию для Microsoft, сосредоточенный на Azure и MVC.
- [Роуэн Миллер](http://www.romiller.com) и другие члены группы разработчиков Entity Framework, которые были полезны при проверке кода, и помогли в отладке многих проблем с миграцией, возник при обновлении руководства по EF 5 и EF 6.

## <a name="troubleshoot-common-errors"></a>Устранение неполадок при распространенных ошибках

### <a name="cannot-createshadow-copy"></a>Не удается создать или теневую копию

Сообщение об ошибке:

> Невозможно создать или теневую копию&lt;"&gt;имяфайла", если этот файл уже существует.

Решение

Подождите несколько секунд и обновите страницу.

### <a name="update-database-not-recognized"></a>Обновление-база данных не распознана

Сообщение об ошибке ( `Update-Database` из команды в PMC):

> Термин "обновление базы данных" не распознается как имя командлета, функции, файла сценария или исполняемой программы. Проверьте правильность написания имени или, если путь включен, проверьте правильность пути и повторите попытку.

Решение

Закройте Visual Studio. Повторно откройте проект и повторите попытку.

### <a name="validation-failed"></a>Проверка не пройдена

Сообщение об ошибке ( `Update-Database` из команды в PMC):

> Проверка не пройдена для одной или нескольких сущностей. Дополнительные сведения см. в свойстве "Ентитивалидатионеррорс".

Решение

Одной из причин этой проблемы являются ошибки проверки при `Seed` выполнении метода. Советы по отладке `Seed` метода см. в разделе [Заполнение и отладка Entity Framework (EF) баз данных](https://blogs.msdn.com/b/rickandy/archive/2013/02/12/seeding-and-debugging-entity-framework-ef-dbs.aspx) .

### <a name="http-50019-error"></a>Ошибка HTTP 500,19

Сообщение об ошибке:

> Ошибка HTTP 500,19-Внутренняя ошибка сервера запрошенная страница недоступна из-за недопустимых данных конфигурации для этой страницы.

Решение

Одним из способов получения этой ошибки может быть наличие нескольких копий решения, каждый из которых использует один и тот же номер порта. Обычно эту проблему можно решить, выполнив все экземпляры Visual Studio, а затем перезапустив проект, над которым вы работаете. Если это не поможет, попробуйте изменить номер порта. Щелкните правой кнопкой мыши файл проекта и выберите пункт Свойства. Перейдите на вкладку **веб** и измените номер порта в текстовом поле **URL-адрес проекта** .

### <a name="error-locating-sql-server-instance"></a>Ошибка при обнаружении экземпляра SQL Server

Сообщение об ошибке:

> При подключении к SQL Server произошла ошибка, связанная с сетью или с определенным экземпляром. Сервер не найден или недоступен. Проверьте правильность имени экземпляра и настройку сервера SQL Server для удаленных подключений. (поставщик: сетевые интерфейсы SQL, ошибка: 26 — ошибка при обнаружении указанного сервера или экземпляра)

Решение

Проверьте строку подключения. Если вы вручную удалили базу данных, измените имя базы данных в строке конструирования.

## <a name="get-the-code"></a>Получите код

[Скачать завершенный проект](https://webpifeed.blob.core.windows.net/webpifeed/Partners/ASP.NET%20MVC%20Application%20Using%20Entity%20Framework%20Code%20First.zip)

## <a name="additional-resources"></a>Дополнительные ресурсы

 Дополнительные сведения о работе с данными с помощью Entity Framework см. на [странице документации EF на сайте MSDN](https://msdn.microsoft.com/data/ee712907) и [ASP.NET Data Access — Рекомендуемые ресурсы](../../../../whitepapers/aspnet-data-access-content-map.md).

Дополнительные сведения о развертывании веб-приложения после его создания см. в разделе [ASP.NET Web Deployment-Рекомендуемые ресурсы](../../../../whitepapers/aspnet-web-deployment-content-map.md) в библиотеке MSDN.

Дополнительные сведения о других темах, связанных с MVC, например о проверке подлинности и авторизации, см. в разделе [ASP.NET MVC-Рекомендуемые ресурсы](../recommended-resources-for-mvc.md).

## <a name="next-steps"></a>Следующие шаги

В этом учебнике рассмотрены следующие задачи.

> [!div class="checklist"]
> * Выполнение прямых SQL-запросов
> * Выполнение запросов без отслеживания
> * Проверенные запросы SQL, отправленные в базу данных

Вы также узнали о следующих возможностях:

> [!div class="checklist"]
> * Создание слоя абстракции
> * Прокси-классы
> * Автоматическое обнаружение изменений
> * Автоматическая проверка
> * Entity Framework Power Tools
> * Исходный код Entity Framework

Эта серия руководств по использованию Entity Framework в приложении MVC ASP.NET. Если вы хотите узнать о Database First EF, см. первую серию руководств по базам данных.
> [!div class="nextstepaction"]
> [Entity Framework Database First](../database-first-development/setting-up-database.md)